#include <stdio.h>
#include "mpi.h"
#include "math.h"
#include <malloc.h>
#include <climits>
#define MCW MPI_COMM_WORLD

#define m 8

struct min {
    int val = INT_MAX;
    int rank;
};

int main(int argc, char* argv[])
{
    int p, rank;
    int A[m][m], b[m], c[m];
    int *locA, *locB;
    int* temp, * rowsTemp;
    struct min min;
    struct min locMin;
    MPI_Status status;
    MPI_Datatype row, subvec;
    MPI_Init(&argc, &argv);
    MPI_Comm_size(MPI_COMM_WORLD, &p);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    int q = (int)sqrt(p);
    const int l = m / q;

    locA = (int*)malloc(l * l * sizeof(int));
    locB = (int*)malloc(l * sizeof(int));
    temp = (int*)malloc(l * sizeof(int));
    rowsTemp = (int*)malloc(l * sizeof(int));

    MPI_Type_vector(l*l, 1, q, MPI_INT, &row);
    MPI_Type_commit(&row);

    MPI_Type_vector(l, 1, q, MPI_INT, &subvec);
    MPI_Type_commit(&subvec);
    MPI_Type_create_resized(subvec, 0, 1*sizeof(int), &subvec);
    MPI_Type_commit(&subvec);

    MPI_Comm rowsComm, colsComm;
    MPI_Comm_split(MCW, rank/q, rank%q, &rowsComm);
    MPI_Comm_split(MCW, rank % q, rank / q, &colsComm);

    int rowsRank, colsRank;
    MPI_Comm_rank(rowsComm, &rowsRank);
    MPI_Comm_rank(colsComm, &colsRank);

    if (rank == 0)
    {
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < m;j++)
            {
                A[i][j] = i * m + j;
                //printf("%d ", A[i][j]);
            }
            //printf("\n");

            b[i] = i;
        }

        for (int i = 0; i < p; i++)
        {
            if (i == 0)
            {
                for (int i = 0; i < l * l; i++)
                {
                    locA[i] = A[i/q][i*q];
                }
            }
            else
            {
                MPI_Send(&A[i/q][i%q], 1, row, i, 0, MCW);
            }
        }
    }
    else
    {
        MPI_Recv(locA, l*l, MPI_INT, 0, 0, MCW, &status);
    }

    MPI_Scatter(b, 1, subvec, locB, l, MPI_INT, 0, rowsComm);
    MPI_Bcast(locB, l, MPI_INT, 0, colsComm);
    /*
     printf("rank: %d\n", rank);
     for (int i = 0; i < l * l; i++)
     {
        printf("%d ", locA[i]);
     }
     printf("\n");
    
    printf("rank %d: ", rank);
    for (int i = 0; i < l; i++)
    {
        printf("%d ", locB[i]);
    }
    printf("\n");
    */
    
    locMin.rank = rank;
    for (int i = 0; i < l * l; i++)
    {
        if (locA[i] < locMin.val)
        {
            locMin.val = locA[i];
        }
    }

    MPI_Reduce(&locMin, &min, 1, MPI_2INT, MPI_MINLOC, 0, MCW);
    MPI_Bcast(&min, 1, MPI_2INT, 0, MCW);


    if (rank == 0)
    {
        for (int i = 0; i < l; i++)
        {
            temp[i] = 0;
            for (int j = 0; j < l; j++)
            {
                temp[i] += locA[j + i * l] * locB[j];
                //printf("%d ", temp[i]);
            }
        }
    }


    MPI_Reduce(temp, rowsTemp, l, MPI_INT, MPI_SUM, 0, MCW);

    if (rowsRank == 0)
    {
        MPI_Gather(rowsTemp, l, MPI_INT, &c[0], l, MPI_INT, min.rank, colsComm);
    }

    if (rank == min.rank) {
        printf("Ja, proces %d, sadrzim najmanji element matrice A.\n", rank);
        for (int j = 0; j < m; j++)
        {
            printf("%d ", c[j]);
        }
    }

    free(locA);
    free(locB);
    free(temp);
    free(rowsTemp);

    MPI_Finalize();
}

